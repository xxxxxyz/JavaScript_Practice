<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
       /*  // 不推荐用  var声明变量，因为var 不产生 block level scope
        for(let i = 0; i < 3; i++) {
            var a = 1
            // console.log(i)
        }

        // console.log(a) */
        // let a = 1
        // let b = 2
        // function f() {
        //     // let a = 1
        //     function g() {
        //         a = 2
        //         console.log(a)
        //     }
        //     g()
        //     console.log(a)
        // }
        // f()
        // console.log(a)

        // // garbage collection
        // const arr = [1,2,3,4]
        // arr = null // 通过赋值null来释放内存
        
        // // 引用计数法
        // let person = {
        //     age: 19,
        //     name: '佩奇',
        // }
        
        // let p = person // 被引用两次
        // person = 1      // 对象引用次数是1
        // p = null    // 被引用次数 0


        // closure
        // function outer() {
        //     let a = 10 
        //     function fn() {
        //         console.log(a)
        //     }
        //     fn()
        // }
        // outer()

        // 通过闭包实现外部可以使用和访问函数内部变量
        // function outer() {
        //     let a = 10
        //     function fn() {
        //         console.log(a)
        //     }
        //     return fn
        // }
        // // 外部如何使用？ => outer 内部  return fn
        // // outer() === fn  === function fn() {}
        // const fun = outer()
        // fun() // => 10 实现外部获得函数内部的值


        // 闭包应用  -- 实现数据私有 -- 统计函数调用次数
        /* let i = 0
        function fn() {
            i++
            console.log(i)
        } */

        // i 作为全局变量容易被任意修改，修改为闭包
        /* function  count () {
            let i = 0
            function fn() {
                i++
                console.log(i)
            }
            return fn */
        // }  // 内存泄漏 Memory Leak
        /* const fun = count()

        //Variable hosting 把所有当前作用域下， var声明的变量提升到当前作用的最前面，只提升声明，不提升赋值
        console.log(num + '件') // => undefined 
        var num = 10

        function fn() {
            console.log(num) // => undefined
            var num = 10
        }
        fn() */


        //** function hosting 会把所有函数声明提升到当前作用域的最前面 只提升函数声明，不提升函数调用
       /*  fn()
        function fn() {
            console.log('函数提升')
        } */

        //** 函数表达式不存在提升现象
        /* fun() // error var相当于声明变量，提升fun变量，没有提升赋值
        var fun = function() {
            console.log('函数表达式')
         } */
        //函数提升出现在相同作用域当中


        //** 函数的参数
        // 动态参数 arguments 包含了调佣函数式传入的所有实参,参数数量不定
        /* function getSum() {
            // console.log(arguments)
            let sum = 0
            for(let i = 0; i < arguments.length; i++) {
                sum += arguments[i]
            }
            console.log(sum)
        }
        getSum(2,3,4,5,435,34) */


        // 剩余参数 ... 提倡使用剩余参数 rest parameters
        /* function getSum(...arr) {
            let sum = 0
            for (let i = 0; i < arr.length; i++) {
                sum += arr[i] 
            }
        }
        getSum(1,2,3,4)
        getSum(1,2,3,4,5) */

        // practice 
        /* const arr = [1,2,3]
        // ...arr === 1,2,3
        // console.log(...arr)
        console.log(Math.max(...arr)) // => 3
        const arr2 = [3,4,5]

        const arr3 = [...arr,...arr2]
        console.log(arr3) */


        //** Arrow Function **//
        /* function fn() {
            console.log('124')
        } */

       /*  const fn = () => {
            console.log('124')
        }
        fn()  // 124 */

        /* const fn = (x) => {
            console.log(x)
        }

        fn(1) // 1 */

        /* const fn = x => {
            console.log(x)
        }
        fn(1) //1 */

        //只有一行代码，可以省略 {}
       /*  const fn = x => console.log(x) 
        fn(2) // 2 */

        // 省略 return
        /* const fn = x => x + x
        console.log(fn(1)) */
        // 直接返回一个对象
       /*  const fn1 = (uname) => ({uname: uname})
        console.log(fn1('Jacky')) */


        //** arrow function parameters
        /* const getSum = (...arr) => {
            let sum = 0
            for (let i = 0; i< arr.length; i++) {
                sum += arr[i]
            }
            return sum
        }
        console.log(getSum(2,4,3)) // => 9 */

        //** arrow function this
        /* const fn = () => {
            console.log(this)  // this指向window
        }
        fn()  */

       /*  const obj = {
            uname: 'pink',
            sayHi: () => {
                console.log(this) //this的指向？ => window
            }
        }

        obj.sayHi() */

        // 3
        const obj = {
            uname: 'pink',
            sayHi: function () {
                console.log(this) // obj
                let i = 10
                const count = () => {
                    console.log(this)  // obj
                }
                count()
            }
        }
        obj.sayHi()
    
    </script>
</body>
</html>